from collections import defaultdict, deque

def solution(scores):
    answer = 0
    
    p = scores[0] # 완호의 점수
    sum_p = sum(p)        
    
    #1 정렬
    scores.sort(key = lambda x:(-x[0], x[1]))

    #2 인센티브 받을 사람 조사 및 랭크 측정
    rank, tmp = 1, 0
    for i in range(len(scores)):
        if p[0] < scores[i][0] and p[1] < scores[i][1]: return -1
        if tmp <= scores[i][1]:
            if sum_p < sum(scores[i]):
                rank += 1
            tmp = scores[i][1]

    answer = rank
    return answer

'''
<풀이>
1. scores배열을 다음 순서로 정렬한다 1: 근무 태도 점수 내림차순, 2: 동료 평가 점수 오름차순
1-1. 1의 과정을 거치면 무조건 해당 인덱스 이전에 가장 큰 동료 평가 점수보다 해당 인덱스의 직원의 동료 평가점수가 낮다면 인센티브를 받지 못하는 직원이라는 것이 보장된다. 
    => 근무 태도 점수 기준으로 내림차순을 했기 때문에 무조건 이전 직원의 근무태도 점수는 크거나 같다는 것이 보장되기 때문에! 
    ex1) (12, 3), (9, 6), (3, 7), (2, 8), (2, 5), (1, 6) 에서는 (2, 5)와 (1, 6)은 인센티브를 받을 수 없다.
    => 이전 직원들의 모든 근무태도 점수가 같다면 동료 평가 점수로만 판단할 수 있나? 라는 의문이 생길 수 있지만 이렇게 되면 동료 평가 점수가 오름차순으로 정렬되기 때문에 문제가 없다.
    ex2) 예시 1 을 다음과 같이 바꾼다. 
    (2, 13) (2, 13), (2, 8), (2, 8), (2, 5), (1, 6)은 다음과 같이 정렬된다.
    (2, 5), (2, 8), (2, 8), (2, 13), (2, 13), (1, 6)
    따라서 동료 평가 점수로만 판단할 수 있다는 것이 보장된다.
2. 따라서 정렬된 scores 배열의 첫 번째 인덱스부터 이전 직원들 중 가장 큰 동료 평가 점수와 비교해서 더 크다면 가장 큰 동료 평가 점수를 갱신하고, 이 때 해당 인덱스의 점수 합이 완호보다 클 때만 rank값을 +1 해준다. 
'''