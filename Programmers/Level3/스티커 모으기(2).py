def solution(sticker):
    answer = 0
    if len(sticker)==1: return sticker[0]
    
    dp1 = sticker[:-1]
    dp2 = sticker[1:]
    for i in range(1, len(sticker)-1):
        if i==1: 
            dp1[i] = max(dp1[i],dp1[i-1])
            dp2[i] = max(dp2[i],dp2[i-1])
        else: 
            dp1[i] = max(dp1[i-1], dp1[i-2]+dp1[i])
            dp2[i] = max(dp2[i-1], dp2[i-2]+dp2[i])
    answer = max(dp1[-1],dp2[-1])
    return answer

print(solution([14, 6, 5, 11, 3, 9, 2, 10])) # 36 => 6,11,9,10
#
# 1: 14, 6, 5, 11, 3, 9, 2
#    14, 14, 19, 25, 25, 34, 34
# 2: 6, 5, 11, 3, 9, 2, 10
#    6, 6, 17, 17, 26, 26, 36
print(solution([1, 3, 2, 5, 4])) # 8 => 3,5
print(solution([1, 2, 3, 10, 4, 5, 11]))
# 1: 1, 2, 3, 10, 4, 5
#    1, 2, 4, 12, 12, 17
# 2: 2, 3, 10, 4, 5, 11
#    2, 3, 12, 12, 17, 23

'''
<풀이>
- 문제 조건: 스티커를 뗸 위치의 좌우 스티커는 찢어져 사용할 수 없다.
           뜯어낸 스티커의 최대합을 구하라
- DP 풀이
0번째 스티커를 뜯으면, 다음에 뜯을 수 있는 스티커의 최소 인덱스는 2번째 스티커다.
1번쨰 스티커를 뜯으면, 다음에 뜯을 수 있는 스티커의 최소 인덱스는 3번쨰 스티커다. 
즉, 홀,짝으로 가장 가까이 있는 스티커 x를 뜯을 수 있으며, x의 양쪽 스티커 y가 더 크다면 y를 골라도 된다.
스티커는 원형리스트로 되어 있기에, 첫번째 스티커를 뜯는다면, 마지막 스티커를 뜯을 수 없고, 두번쨰 스티커를 뜯는다면, 마지막 스티커를 뜯을 수 있게 됨으로
0,1번째 스티커를 기준으로 dp 를 구하기만 하면 된다.
0번째 스티커를 뜯는다면, dp 배열의 범위는 sticker[-1] => 마지막 스티커 전까지
1번쨰 스티커를 뜯는다면, dp 배열의 범위는 sticker[1:] => 첫번쨰 스티커 다음 번째부터

각 dp 배열마다, dp[i] = max(dp[i-1], dp[i-2]+dp[i])의 식을 적용하고,
이때, i가 1인 경우, i-2 값은 참조할 수 없기에, dp[i] = max(dp[i-1],dp[i])의 식을 적용한다.
모든 계산이 끝난 후 dp1, dp2 배열의 끝 값 중 큰 값을 반환한다.
'''