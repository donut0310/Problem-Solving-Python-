def solution(board):
    tmp = 0
    for i in range(len(board)):
        for j in range(len(board[0])):
            if i==0 or j==0 or board[i][j]==0:
                tmp = max(tmp, board[i][j])
                continue

            board[i][j] = min(board[i-1][j], board[i][j-1], board[i-1][j-1]) + 1
            tmp = max(tmp, board[i][j])

    return tmp**2

print(solution([[0,1,1,1],[1,1,1,1],[1,1,1,1],[0,0,1,0]])) # 9
print(solution([[0,0,1,1],[1,1,1,1]])) # 4

'''
<풀이>

DP를 이용한 풀이
행렬의 각 원소들은 행렬상 자신의 왼쪽 원소 A, 위쪽 원소 B, 왼쪽 윗방향 대각선 원소 C, 3가지와 비교하여야 한다.
원소의 값이 1이라면 최소 1*1 크기의 정사각형임을 보장한다. 
먼저 A, B, C 중 최소값을 추출한다. => 최소값 부분부터 더 큰 정사각형을 만들 수 있기 때문!
이후, 최소값에 +1을 한 값을 현재 행렬의 인덱스에 넣어준다.
ex) A, B, C 가 모두 1이라면 현재 행렬의 인덱스의 값은 2가 된다. 즉, 2*2 크기의 정사각형을 만들 수 있게 된다.

이때, 현재 행렬의 인덱스 값이 0이라면 정사각형을 확장할 수 없기 때문에 if절로 분기한다.
또한, 첫 행과 첫 열의 경우 이전의 값을 알 수 없고 자신이 정사각형의 확장 시작점이 되기 때문에 역시 if절로 분기한다.

전체 행열의 인덱스를 탐색하며 위 조건을 만족시킨 후 현재 행렬의 인덱스 값과 최대값을 비교해 갱신한다.
최종적으로 도출된 최대값은 정사각형의 한 변의 최대길이를 의미한다.
'''